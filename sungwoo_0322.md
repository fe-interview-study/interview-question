## PS
### 질문
Hashtable에 데이터를 계속 집어넣게 된다면 버킷은 한정되어있어 opening addressing이나 chaning 기법을 사용해도 문제가 발생합니다. 이런 상황에서 어떻게 테이블을 설계해 효율을 높일 수 있을까?

## 답
헤시 테이블은 헤시 함수를 통해 나온 값을 나머지 연산을 통해 인덱싱을 진행한다. chaning 기법은 헤시 함수에서 같은 값이 나와 충돌이 나는 경우 해결하는 방식이다. 여기에서 헤시 함수의 값을 같게 나오지 못하게 하면 되지 않을까 생각했다.

![R1280x0](https://user-images.githubusercontent.com/48006103/111300432-6acc7c80-8694-11eb-9313-a1ee6ec91f8e.png)


함수를 여러개 사용해 값이 동일하게 나오지 않게 하려면, 함수를 여러개 사용하면 되지 않을까 생각한다. 참고 그림에 나와있는 예시에서는 함수 하나를 사용해 16으로 나머지 연산을 실행해 나온 값으로 버킷의 인덱스를 찾아갔다. 이를 함수 2개를 사용해 각각 4 나머지 연산을 사용한다면 겹칠 확률이 낮아질 것이다.

## Network
### 질문1
브라우저에 google.com을 접속할 때 어떤 일이 발생할까?

### 답1
브라우저에서 주소를 입력해 웹사이트를 방문하게 된다면, 가장 먼저 브라우저에서는 사용자가 입력한 주소를 HTTP request로 변환을 시킨다. 이때 HTTP 메소드는 GET으로 요청하게 되고, 이때 사용자의 로컬 정보를 HTTP request 헤더에 넣어 같이 전달한다.

이렇게 만들어진 request는 가장 먼저 DNS에 방문한다. 사용자는 "https://www.google.com"을 넣어 request를 보냈음으로 실제로 어떤 서버에 방문해야할지 모르는 상태이다. 도메인을 IP로 변경하기 위해 DNS에 방문해 www.google.com이 어떤 ip를 가리키는지 찾아, 그쪽으로 request를 보내게 된다.

최종적으로 서버에 도착한 request는 사용자의 방문 정보와 경로를 확인해 사용자가 원하는 response를 만들어 사용자에게 보내게 된다.

사용자가 서버에게 response를 받게 된다면, 가장 먼저 그 response의 상태를 response code로 확인한다. 상태가 좋지 않다면 다시 요청하거나 그 상태를 사용자에게 보고한다.

![](https://snyung.com/static/6ce5b9c10c0befaf649260c5143aa664/39c09/Webkit.png)
그리고 가져온 정보를 바탕으로 사용자에게 정보를 보여주게 되는데, 대부분의 브라우저 간 통신은 HTML문서를 통해 서버에게 데이터를 전달받게 된다. 브라우저는 HTML에서 가장 먼저 head 태그 안에 있는 script 태그들을 보며 추가로 필요한 데이터를 서버, 또는 외부에 요청한다. 그리고 HTML을 파싱해 돔 트리로 변환한다.

외부에서 css도 가져오게 된다면 css 파일을 Style rule로 파싱해, 돔트리와 스타일룰을 합쳐 렌더링 트리로 변환한다. 최종적으로 브라우저는 렌더링 트리를 바탕으로 사용자에게 정보를 보여주게 된다.

### 질문2
HTTP란?

### 답2
HTTP는 HyperText Trasfer Protocol의 약자로 1대1간 정보를 주고받는 프로토콜을 말한다.

## React
### 질문
state를 직접 변경하지 않고 setState를 통해 변경하는 이유는?

### 답
React에서는 state가 변경되는걸 인지해 컴포넌트를 리랜더링하는데, state값을 직접 변경하면 코어 리엑트에서 값이 변경되는지 알 수 없다. 따라서 setState를 통해 값을 변경하면, 코어 리엑트에서 컴포넌트를 다시 랜더링하는 식으로 구현이 되어있기 때문에 setState를 통해 state값을 변경해야 한다.

## OS
OS쪽은 잘 모르는데 이번 질문은 아예 처음 보는 개념이다보니 답을 할수 없을 것 같습니다 ㅠㅠ


## JS
### 질문
call, apply, bind란 무엇이며 이들의 공통점과 차이점은?

### 답
JS 함수에서 this는 호출 당시 상위 인자를 기준으로 this가 바인딩되는데, call, apply, bind를 사용하면 this를 바인딩하는 오브젝트를 지정해줄수 있다.

이 함수들의 차이는 함수 실행시 매개변수를 넣는 차이점에 있습니다. call과 apply는 사용시 함수에 넣을 매개변수도 받는데, call의 경우 일반 매개변수를 받듯 여러 매개변수를 받지만, apply의 경우 매개변수를 배열에 넣어 받게 됩니다.

bind는 call과 apply와는 사뭇 다릅니다. call과 apply는 바인딩 한 이후 함수를 실행까지 하는데, 함수의 this만 바인딩하고 바인딩되어있는 함수를 리턴합니다. 